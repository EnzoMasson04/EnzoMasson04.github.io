<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TD3 - Ex1 Part2 - Interactions Leaflet &lt;-&gt; Three.js</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html, body {height: 100%; margin: 0; background: #0b1020; color: #eaeff7; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
    .grid {display: grid; grid-template-columns: 1fr 1fr; height: 100%;}
    #three, #map {position: relative;}
    #three canvas, #map {width: 100%; height: 100%;}
    #hud {
      position: absolute; left: 12px; top: 12px; z-index: 10;
      background: rgba(0,0,0,.5); padding: 10px 12px; border-radius: 8px;
      line-height: 1.35; font-size: 14px;
    }
    #mapHud {
      position: absolute; right: 12px; top: 12px; z-index: 10;
      background: rgba(0,0,0,.55); padding: 10px 12px; border-radius: 8px;
      line-height: 1.35; font-size: 14px;
    }
    a {color: #86c8ff;}
    @media (max-width: 900px){
      .grid {grid-template-columns: 1fr; grid-auto-rows: 50vh 50vh;}
    }
  </style>
 
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.159.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="grid">
    <div id="three">
      <div id="hud">
        
      </div>
    </div>
    <div id="map">
      <div id="mapHud">Carte Leaflet (OSM)</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import L from 'https://cdn.skypack.dev/leaflet@1.9.4';
 
    const threeRoot = document.getElementById('three');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, threeRoot.clientWidth / threeRoot.clientHeight, 0.1, 1000);
    camera.position.set(0, 1.8, 3.2);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(threeRoot.clientWidth, threeRoot.clientHeight);
    threeRoot.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.85);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 1);
    dir.position.set(5, 3, 2);
    scene.add(dir);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 1.6;
    controls.maxDistance = 6;
 
    const earthRadius = 1;
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);
    const earthGeo = new THREE.SphereGeometry(earthRadius, 64, 64);
    const tex = await new THREE.TextureLoader().loadAsync('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg');
    const bump = await new THREE.TextureLoader().loadAsync('https://unpkg.com/three-globe/example/img/earth-topology.png');
    const earthMat = new THREE.MeshPhongMaterial({ map: tex, bumpMap: bump, bumpScale: 0.02, specular: 0x222222, shininess: 12 });
    const earthMesh = new THREE.Mesh(earthGeo, earthMat);
    earthGroup.add(earthMesh);

    const atmo = new THREE.Mesh(new THREE.SphereGeometry(earthRadius*1.02, 64, 64), new THREE.MeshBasicMaterial({color:0x99bbff, transparent:true, opacity:0.12, side:THREE.BackSide}));
    earthGroup.add(atmo);

    const deg2rad = d => d * Math.PI / 180;
    function latLonToVector3(latDeg, lonDeg, radius = earthRadius, altitude = 0) {
      const lat = deg2rad(latDeg), lon = deg2rad(lonDeg);
      const r = radius + altitude;
      const x = r * Math.cos(lat) * Math.cos(lon);
      const y = r * Math.sin(lat);
      const z = r * Math.cos(lat) * Math.sin(lon);
      return new THREE.Vector3(x, y, z);
    }
    function cartesianToLatLon(v) {
      const r = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
      const lat = Math.asin(v.y / r) * 180 / Math.PI;
      const lon = Math.atan2(v.z, v.x) * 180 / Math.PI;
      return { lat, lon };
    }

    function makeDot(color = 0xff3333, scale = 0.03) {
      return new THREE.Mesh(new THREE.SphereGeometry(scale, 16, 16), new THREE.MeshBasicMaterial({color}));
    }
    const texLoader = new THREE.TextureLoader(); texLoader.setCrossOrigin('anonymous');
    function makeFlagSprite(urlPng, size = 0.14) {
      const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: texLoader.load(urlPng), depthTest: true, depthWrite:false }));
      s.scale.set(size*1.6, size, 1);
      return s;
    }
 
    if ('geolocation' in navigator) {
      navigator.geolocation.getCurrentPosition(pos => {
        const { latitude, longitude } = pos.coords;
        const dot = makeDot(0xff4444, 0.03);
        dot.position.copy(latLonToVector3(latitude, longitude, earthRadius, 0.02));
        earthGroup.add(dot);
      });
    }
 
    const flagSprites = [];
    async function addCountryFlags(limit = 60) {
      try {
        const resp = await fetch('https://restcountries.com/v3.1/all?fields=name,latlng,cca2,flags');
        const countries = await resp.json();
        let c = 0;
        for (const ct of countries) {
          if (!ct.latlng || ct.latlng.length < 2 || !ct.flags?.png) continue;
          const [lat, lon] = ct.latlng;
          const s = makeFlagSprite(ct.flags.png, 0.08);
          s.position.copy(latLonToVector3(lat, lon, earthRadius, 0.03));
          s.userData = { country: ct.name?.common || ct.cca2, lat, lon };
          earthGroup.add(s);
          flagSprites.push(s);
          if (++c >= limit) break;
        }
      } catch(e) { console.warn('restcountries fail', e); }
    }
    addCountryFlags();
 
    function pointToFront(lat, lon) {
      const target = latLonToVector3(lat, lon).normalize();
      const front = new THREE.Vector3(0,0,1);
      const q = new THREE.Quaternion().setFromUnitVectors(target, front);
      earthGroup.quaternion.copy(q);
      autoRotate = false;
    }
 
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    function onThreeClick(evt) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((evt.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((evt.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
   
      let isFlag = raycaster.intersectObjects(flagSprites, true)[0];
      if (isFlag) {
        const { lat, lon } = isFlag.object.userData;
        map.setView([lat, lon], 4);
        pointToFront(lat, lon);
        return;
      } 
      let hit = raycaster.intersectObject(earthMesh, true)[0];
      if (hit) {
        const r = hit.point.length();
        const lat = Math.asin(hit.point.y / r) * 180 / Math.PI;
        const lon = Math.atan2(hit.point.z, hit.point.x) * 180 / Math.PI;
        map.setView([lat, lon], 4);
        pointToFront(lat, lon);
      }
    }
    renderer.domElement.addEventListener('pointerdown', onThreeClick);
 
    let autoRotate = true;
    function animate() {
      requestAnimationFrame(animate);
      if (autoRotate) earthGroup.rotation.y += 0.0012;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    function resizeThree() {
      const w = threeRoot.clientWidth, h = threeRoot.clientHeight;
      camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w, h);
    }
 
    const mapRoot = document.getElementById('map');
    const map = L.map(mapRoot).setView([48.8566, 2.3522], 3);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    map.on('click', (e) => {
      const { lat, lng } = e.latlng;
      pointToFront(lat, lng);
    });
 
    window.addEventListener('resize', () => {
      resizeThree();
      map.invalidateSize();
    });
  </script>
</body>
</html>
