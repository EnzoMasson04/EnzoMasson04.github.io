<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ex.1 SIMPLE – Globe 3D + Leaflet</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html, body { margin:0; height:100%; }
    #layout { display:flex; height:100vh; width:100vw; }
    #three { flex:1; position:relative; background:#000; }
    #map { flex:1; }
    #hud { position:absolute; left:8px; top:8px; color:#fff; background:rgba(0,0,0,.6); padding:6px 8px; border-radius:6px; font-family: sans-serif; font-size:13px; }
  </style>
</head>
<body>
  <div id="layout">
    <div id="three">
      <div id="hud">Globe 3D (clic = recadre carte)</div>
    </div>
    <div id="map"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // ------- THREE very simple globe (no external textures) -------
  const container = document.getElementById('three');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
  camera.position.set(0, 0, 3);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  container.appendChild(renderer.domElement);

  // basic light
  scene.add(new THREE.AmbientLight(0xffffff, 0.9));

  // Earth: simple colored material (no texture to avoid CORS)
  const earthRadius = 1;
  const earth = new THREE.Mesh(
    new THREE.SphereGeometry(earthRadius, 48, 48),
    new THREE.MeshStandardMaterial({ color: 0x2266aa, roughness: 0.6, metalness: 0.0 })
  );
  scene.add(earth);

  // helpers: lat/lon <-> xyz
  function latLonToXYZ(lat, lon, r=earthRadius){
    const phi = (90 - lat) * Math.PI/180;
    const theta = (lon + 180) * Math.PI/180;
    const x = -r * Math.sin(phi) * Math.cos(theta);
    const z =  r * Math.sin(phi) * Math.sin(theta);
    const y =  r * Math.cos(phi);
    return new THREE.Vector3(x,y,z);
  }
  function xyzToLatLon(v){
    const r = v.length();
    const phi = Math.acos(THREE.MathUtils.clamp(v.y/r, -1, 1));
    const theta = Math.atan2(v.z, -v.x);
    const lat = 90 - THREE.MathUtils.radToDeg(phi);
    const lon = THREE.MathUtils.radToDeg(theta) - 180;
    return {lat, lon: ((lon+180)%360+360)%360-180};
  }

  // Raycaster click -> recenter Leaflet
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  renderer.domElement.addEventListener('click', (ev)=>{
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const hit = raycaster.intersectObject(earth);
    if(hit.length){
      const p = hit[0].point.clone().normalize().multiplyScalar(earthRadius);
      const {lat, lon} = xyzToLatLon(p);
      map.setView([lat, lon], Math.max(map.getZoom(), 3));
      hud.textContent = `Clique: lat=${lat.toFixed(3)}, lon=${lon.toFixed(3)}`;
    }
  });

  // animate
  function resize(){
    const w = container.clientWidth, h = container.clientHeight;
    renderer.setSize(w,h,false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);
  resize();

  function animate(){
    requestAnimationFrame(animate);
    earth.rotation.y += 0.002;
    renderer.render(scene, camera);
  }
  animate();

  // ------- Leaflet minimal map -------
  const map = L.map('map').setView([48.8566, 2.3522], 3);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  const hud = document.getElementById('hud');

  // Map click -> rotate globe so (lat,lon) is in front (very simple)
  map.on('click', (e)=>{
    const {lat, lng} = e.latlng;
    // We set rotations roughly: yaw around Y by lon, pitch around X by -lat
    earth.rotation.y = THREE.MathUtils.degToRad(lng);
    earth.rotation.x = THREE.MathUtils.degToRad(-lat);
    hud.textContent = `Carte: aller à lat=${lat.toFixed(3)}, lon=${lng.toFixed(3)}`;
  });

  // Add a few simple markers on globe (colored dots)
  function addDot(lat, lon, color=0xff5533, size=0.02){
    const m = new THREE.Mesh(new THREE.SphereGeometry(size, 12, 12),
                             new THREE.MeshStandardMaterial({color}));
    m.position.copy(latLonToXYZ(lat, lon, earthRadius + size*1.5));
    scene.add(m);
  }
  addDot(48.8566, 2.3522, 0xffaa00);   // Paris
  addDot(40.7128, -74.0060, 0x33ffaa); // NYC
  addDot(35.6762, 139.6503, 0x66ccff); // Tokyo

  // Optional: geolocate user (non-blocking)
  if('geolocation' in navigator){
    navigator.geolocation.getCurrentPosition(
      (pos)=>{
        const {latitude, longitude} = pos.coords;
        addDot(latitude, longitude, 0x00ff88, 0.028);
      },
      ()=>{},
      { enableHighAccuracy:true, timeout:8000 }
    );
  }
  </script>
</body>
</html>
