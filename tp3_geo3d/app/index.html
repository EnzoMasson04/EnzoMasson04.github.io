<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ex.1 AVANCÉ – Globe 3D + Leaflet + Drapeaux</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root {
      --card:#0b1220; --card2:#0f172a; --acc:#22d3ee; --txt:#e5e7eb;
    }
    html, body { margin:0; height:100%; background:#000; color:var(--txt); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #layout { display:grid; grid-template-columns: 1.1fr 0.9fr; height:100vh; }
    #three { position:relative; overflow:hidden; }
    #map { position:relative; }
    #panel {
      position:absolute; top:14px; left:14px; z-index:10;
      background: linear-gradient(180deg, rgba(15,23,42,.9), rgba(2,6,23,.85));
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      border-radius:14px; padding:12px 14px; min-width: 260px;
    }
    #panel h3 { margin:0 0 8px 0; font-size:15px; letter-spacing:.3px; color:#8dd3ff; }
    #panel .row { display:flex; gap:8px; flex-wrap:wrap; }
    .btn {
      background:#0ea5e9; border:none; color:#001018; font-weight:600;
      padding:8px 10px; border-radius:10px; cursor:pointer;
      transition:.15s transform ease, .2s opacity;
    }
    .btn.secondary { background:#1f2937; color:#e5e7eb; }
    .btn:hover { transform: translateY(-1px); opacity:.95; }
    #hud {
      position:absolute; left:14px; bottom:14px; z-index:10; opacity:.9;
      background: rgba(0,0,0,.55); padding:6px 10px; border-radius:10px; font-size:13px;
      border: 1px solid rgba(255,255,255,.08);
    }
    #legend {
      position:absolute; right:14px; top:14px; z-index:10; font-size:12px; opacity:.9;
      background: rgba(0,0,0,.5); padding:8px 10px; border-radius:10px;
      border: 1px solid rgba(255,255,255,.08);
    }
    @media (max-width: 900px) {
      #layout { grid-template-columns: 1fr; grid-template-rows: 55% 45%; }
    }
  </style>
</head>
<body>
  <div id="layout">
    <div id="three">
      <div id="panel">
        <h3>Globe 3D – Interactions</h3>
        <div class="row">
          <button id="btnLoadCountries" class="btn">Charger des pays + drapeaux</button>
          <button id="btnParis" class="btn secondary">Paris</button>
          <button id="btnTokyo" class="btn secondary">Tokyo</button>
          <button id="btnNYC" class="btn secondary">New York</button>
        </div>
      </div>
      <div id="legend">Clic sur le globe = recadrer la carte</div>
      <div id="hud">Prêt.</div>
    </div>
    <div id="map"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // ================== THREE – Scene ==================
  const container = document.getElementById('three');
  const hud = document.getElementById('hud');

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
  camera.position.set(0, 0.15, 3.2);

  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  container.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = false;
  controls.minDistance = 2.2;
  controls.maxDistance = 6;

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(4, 2.5, 1.5);
  scene.add(dir);

  // Earth with texture (fallback safe color if blocked)
  const earthRadius = 1;
  const sphereGeo = new THREE.SphereGeometry(earthRadius, 64, 64);
  const loader = new THREE.TextureLoader();
  const earth = new THREE.Mesh(sphereGeo, new THREE.MeshStandardMaterial({ color:0x1d3a63 }));
  scene.add(earth);

  // try to load texture (CORS ok on threejs.org)
  loader.load(
    "https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg",
    (tx)=>{ earth.material.map = tx; earth.material.needsUpdate = true; },
    undefined,
    ()=>{ /* keep solid color */ }
  );

  // Subtle atmosphere glow (cheap)
  const atmGeo = new THREE.SphereGeometry(earthRadius*1.03, 48, 48);
  const atmMat = new THREE.MeshBasicMaterial({ color:0x8dd3ff, transparent:true, opacity:0.08, blending:THREE.AdditiveBlending });
  const atmosphere = new THREE.Mesh(atmGeo, atmMat);
  scene.add(atmosphere);

  // ========== Helpers lat/lon <-> xyz ==========
  function latLonToXYZ(lat, lon, r=earthRadius){
    const phi = (90 - lat) * Math.PI/180;
    const theta = (lon + 180) * Math.PI/180;
    const x = -r * Math.sin(phi) * Math.cos(theta);
    const z =  r * Math.sin(phi) * Math.sin(theta);
    const y =  r * Math.cos(phi);
    return new THREE.Vector3(x,y,z);
  }
  function xyzToLatLon(v){
    const r = v.length();
    const phi = Math.acos(THREE.MathUtils.clamp(v.y/r, -1, 1));
    const theta = Math.atan2(v.z, -v.x);
    const lat = 90 - THREE.MathUtils.radToDeg(phi);
    const lon = THREE.MathUtils.radToDeg(theta) - 180;
    return {lat, lon: ((lon+180)%360+360)%360-180};
  }

  // Markers
  function addDot(lat, lon, color=0xff5533, size=0.02){
    const m = new THREE.Mesh(new THREE.SphereGeometry(size, 12, 12),
                             new THREE.MeshStandardMaterial({color}));
    m.position.copy(latLonToXYZ(lat, lon, earthRadius + size*1.5));
    scene.add(m);
    return m;
  }

  // Sprite flags
  const textureLoader = new THREE.TextureLoader();
  function addFlag(lat, lon, flagUrl, label="", scale=0.26){
    const pos = latLonToXYZ(lat, lon, earthRadius + 0.02);
    const tex = textureLoader.load(flagUrl, undefined, undefined, ()=>{});
    const mat = new THREE.SpriteMaterial({ map: tex, depthTest:true });
    const sprite = new THREE.Sprite(mat);
    sprite.position.copy(pos);
    sprite.scale.set(scale, scale*0.66, 1);
    scene.add(sprite);
    sprite.userData.type = "flag";
    sprite.userData.lat = lat; sprite.userData.lon = lon; sprite.userData.label = label;
    return sprite;
  }

  // User geoloc (optional)
  if('geolocation' in navigator){
    navigator.geolocation.getCurrentPosition(
      (pos)=>{
        const {latitude, longitude} = pos.coords;
        addDot(latitude, longitude, 0x00ff88, 0.03);
        hud.textContent = `Ma position: ${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
      },
      ()=>{},
      { enableHighAccuracy:true, timeout:8000 }
    );
  }

  // ================== Leaflet ==================
  const map = L.map('map').setView([48.8566, 2.3522], 3);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19, attribution:'&copy; OpenStreetMap'}).addTo(map);

  // Map -> 3D : click to face
  function faceLatLon(lat, lon, speed=0.06){
    // target rotations
    const targetY = THREE.MathUtils.degToRad(lon);
    const targetX = THREE.MathUtils.degToRad(-lat);
    rotTarget.y = targetY;
    rotTarget.x = targetX;
    rotSpeed = speed;
  }
  map.on('click', (e)=>{
    faceLatLon(e.latlng.lat, e.latlng.lng);
    hud.textContent = `Carte: lat=${e.latlng.lat.toFixed(3)}, lon=${e.latlng.lng.toFixed(3)}`;
  });

  // 3D -> Map : raycast earth OR flag
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  renderer.domElement.addEventListener('click', (ev)=>{
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    if(!intersects.length) return;
    let i = intersects.find(h=>h.object === earth) || intersects[0];
    if(i.object.userData.type === "flag"){
      map.setView([i.object.userData.lat, i.object.userData.lon], Math.max(map.getZoom(), 4));
      hud.textContent = `Drapeau: ${i.object.userData.label}`;
      return;
    }
    if(i.object === earth){
      const p = i.point.clone().normalize().multiplyScalar(earthRadius);
      const {lat, lon} = xyzToLatLon(p);
      map.setView([lat, lon], Math.max(map.getZoom(), 4));
      hud.textContent = `Globe: lat=${lat.toFixed(3)}, lon=${lon.toFixed(3)}`;
    }
  });

  // Buttons
  document.getElementById('btnParis').onclick = ()=>faceLatLon(48.8566, 2.3522);
  document.getElementById('btnTokyo').onclick = ()=>faceLatLon(35.6762, 139.6503);
  document.getElementById('btnNYC').onclick = ()=>faceLatLon(40.7128, -74.0060);

  document.getElementById('btnLoadCountries').onclick = async ()=>{
    hud.textContent = "Chargement des pays...";
    try{
      const res = await fetch('https://restcountries.com/v3.1/all');
      const arr = await res.json();
      const picks = ["France","United States","Japan","Brazil","Morocco","Australia","India","Canada","Argentina","South Africa","Egypt","Spain","Italy","Germany"];
      arr.filter(c=>c.name && picks.includes(c.name.common)).forEach(c=>{
        const latlng = c.latlng || [0,0];
        const flag = (c.flags && (c.flags.png || c.flags.svg)) || null;
        if(flag) addFlag(latlng[0], latlng[1], flag, c.name.common);
      });
      hud.textContent = "Pays + drapeaux ajoutés.";
    }catch(e){
      hud.textContent = "Échec API pays (offline/CORS). On reste en mode simple.";
    }
  };

  // Resize & Animate
  function onResize(){
    const w = container.clientWidth, h = container.clientHeight;
    renderer.setSize(w,h,false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize); onResize();

  const rotTarget = {x:0,y:0}; let rotSpeed = 0.04;
  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    // gentle auto-rotate
    earth.rotation.y += 0.0008;
    atmosphere.rotation.y = earth.rotation.y * 1.03;
    // ease to target
    earth.rotation.y += (rotTarget.y - earth.rotation.y) * rotSpeed;
    earth.rotation.x += (rotTarget.x - earth.rotation.x) * rotSpeed;
    renderer.render(scene, camera);
  }
  renderer.setAnimationLoop(animate);
  </script>
</body>
</html>
