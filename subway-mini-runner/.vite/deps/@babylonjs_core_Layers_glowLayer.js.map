{
  "version": 3,
  "sources": ["../../dev/core/src/PostProcesses/thinBlurPostProcess.ts", "../../dev/core/src/PostProcesses/blurPostProcess.ts", "../../dev/core/src/Layers/thinEffectLayer.ts", "../../dev/core/src/Layers/effectLayer.ts", "../../dev/core/src/Loading/Plugins/babylonFileParser.function.ts", "../../dev/core/src/Layers/effectLayerSceneComponent.ts", "../../dev/core/src/Layers/thinGlowLayer.ts", "../../dev/core/src/Layers/glowLayer.ts"],
  "sourcesContent": ["// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, AbstractEngine, EffectWrapperCreationOptions, Vector2, Effect } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Post process used to apply a blur effect\r\n */\r\nexport class ThinBlurPostProcess extends EffectWrapper {\r\n    /**\r\n     * The vertex shader url\r\n     */\r\n    public static readonly VertexUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"delta\", \"direction\"];\r\n\r\n    /**\r\n     * The list of samplers used by the effect\r\n     */\r\n    public static readonly Samplers = [\"circleOfConfusionSampler\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/kernelBlur.fragment\"), import(\"../ShadersWGSL/kernelBlur.vertex\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/kernelBlur.fragment\"), import(\"../Shaders/kernelBlur.vertex\")]));\r\n        }\r\n    }\r\n\r\n    protected _kernel: number;\r\n    protected _idealKernel: number;\r\n    protected _packedFloat: boolean = false;\r\n    private _staticDefines: string = \"\";\r\n\r\n    /**\r\n     * Constructs a new blur post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param direction Direction in which to apply the blur\r\n     * @param kernel Kernel size of the blur\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, direction?: Vector2, kernel?: number, options?: EffectWrapperCreationOptions) {\r\n        const blockCompilationFinal = !!options?.blockCompilation;\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinBlurPostProcess.FragmentUrl,\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            blockCompilation: true,\r\n        });\r\n\r\n        this.options.blockCompilation = blockCompilationFinal;\r\n\r\n        if (direction !== undefined) {\r\n            this.direction = direction;\r\n        }\r\n        if (kernel !== undefined) {\r\n            this.kernel = kernel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Width of the texture to apply the blur on\r\n     */\r\n    public textureWidth: number = 0;\r\n\r\n    /**\r\n     * Height of the texture to apply the blur on\r\n     */\r\n    public textureHeight: number = 0;\r\n\r\n    /** The direction in which to blur the image. */\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    public set kernel(v: number) {\r\n        if (this._idealKernel === v) {\r\n            return;\r\n        }\r\n\r\n        v = Math.max(v, 1);\r\n        this._idealKernel = v;\r\n        this._kernel = this._nearestBestKernel(v);\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._idealKernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    public set packedFloat(v: boolean) {\r\n        if (this._packedFloat === v) {\r\n            return;\r\n        }\r\n        this._packedFloat = v;\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._packedFloat;\r\n    }\r\n\r\n    public override bind() {\r\n        super.bind();\r\n        this._drawWrapper.effect!.setFloat2(\"delta\", (1 / this.textureWidth) * this.direction.x, (1 / this.textureHeight) * this.direction.y);\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void {\r\n        // Generate sampling offsets and weights\r\n        const N = this._kernel;\r\n        const centerIndex = (N - 1) / 2;\r\n\r\n        // Generate Gaussian sampling weights over kernel\r\n        let offsets = [];\r\n        let weights = [];\r\n        let totalWeight = 0;\r\n        for (let i = 0; i < N; i++) {\r\n            const u = i / (N - 1);\r\n            const w = this._gaussianWeight(u * 2.0 - 1);\r\n            offsets[i] = i - centerIndex;\r\n            weights[i] = w;\r\n            totalWeight += w;\r\n        }\r\n\r\n        // Normalize weights\r\n        for (let i = 0; i < weights.length; i++) {\r\n            weights[i] /= totalWeight;\r\n        }\r\n\r\n        // Optimize: combine samples to take advantage of hardware linear sampling\r\n        // Walk from left to center, combining pairs (symmetrically)\r\n        const linearSamplingWeights = [];\r\n        const linearSamplingOffsets = [];\r\n\r\n        const linearSamplingMap = [];\r\n\r\n        for (let i = 0; i <= centerIndex; i += 2) {\r\n            const j = Math.min(i + 1, Math.floor(centerIndex));\r\n\r\n            const singleCenterSample = i === j;\r\n\r\n            if (singleCenterSample) {\r\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n            } else {\r\n                const sharedCell = j === centerIndex;\r\n\r\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\r\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\r\n\r\n                if (offsetLinear === 0) {\r\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\r\n                } else {\r\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\r\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < linearSamplingMap.length; i++) {\r\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\r\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\r\n        }\r\n\r\n        // Replace with optimized\r\n        offsets = linearSamplingOffsets;\r\n        weights = linearSamplingWeights;\r\n\r\n        // Generate shaders\r\n        const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === ShaderLanguage.WGSL ? 1 : 0); // Because of the additional builtins\r\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\r\n\r\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\r\n\r\n        let defines = \"\";\r\n        defines += this._staticDefines;\r\n\r\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\r\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\r\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\n`;\r\n            varyingCount--;\r\n        }\r\n\r\n        for (let i = 0; i < varyingCount; i++) {\r\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\n`;\r\n        }\r\n\r\n        let depCount = 0;\r\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\r\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\n`;\r\n            depCount++;\r\n        }\r\n\r\n        if (this.packedFloat) {\r\n            defines += `#define PACKEDFLOAT 1`;\r\n        }\r\n\r\n        this.options.blockCompilation = false;\r\n\r\n        this.updateEffect(\r\n            defines,\r\n            null,\r\n            null,\r\n            {\r\n                varyingCount: varyingCount,\r\n                depCount: depCount,\r\n            },\r\n            onCompiled,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\r\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\r\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\r\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\r\n     * The gaps between physical kernels are compensated for in the weighting of the samples\r\n     * @param idealKernel Ideal blur kernel.\r\n     * @returns Nearest best kernel.\r\n     */\r\n    protected _nearestBestKernel(idealKernel: number): number {\r\n        const v = Math.round(idealKernel);\r\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\r\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\r\n                return Math.max(k, 3);\r\n            }\r\n        }\r\n        return Math.max(v, 3);\r\n    }\r\n\r\n    /**\r\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\r\n     * @param x The point on the Gaussian distribution to sample.\r\n     * @returns the value of the Gaussian function at x.\r\n     */\r\n    protected _gaussianWeight(x: number): number {\r\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\r\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\r\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\r\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\r\n        // truncated at around 1.3% of peak strength.\r\n\r\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\r\n        const sigma = 1 / 3;\r\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\r\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\r\n        const weight = (1.0 / denominator) * Math.exp(exponent);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Generates a string that can be used as a floating point number in GLSL.\r\n     * @param x Value to print.\r\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\r\n     * @returns GLSL float string.\r\n     */\r\n    protected _glslFloat(x: number, decimalFigures = 8) {\r\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\r\n    }\r\n}\r\n", "import type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, serializeAsVector2 } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { ThinBlurPostProcess } from \"./thinBlurPostProcess\";\r\n\r\n/**\r\n * The Blur Post Process which blurs an image based on a kernel and direction.\r\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\r\n */\r\nexport class BlurPostProcess extends PostProcess {\r\n    /** The direction in which to blur the image. */\r\n    @serializeAsVector2()\r\n    public get direction() {\r\n        return this._effectWrapper.direction;\r\n    }\r\n\r\n    public set direction(value: Vector2) {\r\n        this._effectWrapper.direction = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    @serialize()\r\n    public set kernel(v: number) {\r\n        this._effectWrapper.kernel = v;\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._effectWrapper.kernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    @serialize()\r\n    public set packedFloat(v: boolean) {\r\n        this._effectWrapper.packedFloat = v;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._effectWrapper.packedFloat;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BlurPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BlurPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinBlurPostProcess;\r\n\r\n    /**\r\n     * Creates a new instance BlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param direction The direction in which to blur the image.\r\n     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param defines\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        defines = \"\",\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        const blockCompilationFinal = typeof options === \"number\" ? blockCompilation : !!options.blockCompilation;\r\n        const localOptions = {\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            indexParameters: { varyingCount: 0, depCount: 0 },\r\n            textureFormat,\r\n            defines,\r\n            ...(options as PostProcessOptions),\r\n            blockCompilation: true,\r\n        };\r\n\r\n        super(name, ThinBlurPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinBlurPostProcess(name, engine, undefined, undefined, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this._effectWrapper.options.blockCompilation = blockCompilationFinal;\r\n\r\n        this.direction = direction;\r\n        this.onApplyObservable.add(() => {\r\n            this._effectWrapper.textureWidth = this._outputTexture ? this._outputTexture.width : this.width;\r\n            this._effectWrapper.textureHeight = this._outputTexture ? this._outputTexture.height : this.height;\r\n        });\r\n\r\n        this.kernel = kernel;\r\n    }\r\n\r\n    public override updateEffect(\r\n        _defines: Nullable<string> = null,\r\n        _uniforms: Nullable<string[]> = null,\r\n        _samplers: Nullable<string[]> = null,\r\n        _indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        this._effectWrapper._updateParameters(onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new BlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.direction,\r\n                    parsedPostProcess.kernel,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    undefined,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\r\n", "import type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { EffectWrapperCreationOptions } from \"core/Materials/effectRenderer\";\r\nimport { EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\nimport { BindMorphTargetParameters, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances } from \"../Materials/materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { ObjectRenderer } from \"core/Rendering/objectRenderer\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"core/Engines/engine\";\r\n\r\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n * @internal\r\n */\r\nexport class ThinGlowBlurPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"glowBlurPostProcess\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"screenSize\", \"direction\", \"blurWidth\"];\r\n\r\n    constructor(\r\n        name: string,\r\n        engine: Nullable<AbstractEngine> = null,\r\n        public direction: Vector2,\r\n        public kernel: number,\r\n        options?: EffectWrapperCreationOptions\r\n    ) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinGlowBlurPostProcess.FragmentUrl,\r\n            uniforms: ThinGlowBlurPostProcess.Uniforms,\r\n        });\r\n    }\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/glowBlurPostProcess.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/glowBlurPostProcess.fragment\"));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n\r\n    public textureWidth: number = 0;\r\n\r\n    public textureHeight: number = 0;\r\n\r\n    public override bind() {\r\n        super.bind();\r\n        this._drawWrapper.effect!.setFloat2(\"screenSize\", this.textureWidth, this.textureHeight);\r\n        this._drawWrapper.effect!.setVector2(\"direction\", this.direction);\r\n        this._drawWrapper.effect!.setFloat(\"blurWidth\", this.kernel);\r\n    }\r\n}\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IThinEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio?: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independent blur. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_BYTE\r\n     */\r\n    mainTextureType?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation. Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode?: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera?: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId?: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinEffectLayer {\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _mergeDrawWrapper: DrawWrapper[];\r\n    private _dontCheckIfReady = false;\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: AbstractEngine;\r\n    /** @internal */\r\n    public _options: Required<IThinEffectLayerOptions>;\r\n    protected _objectRenderer: ObjectRenderer;\r\n    /** @internal */\r\n    public _shouldRender = true;\r\n    /** @internal */\r\n    public _emissiveTextureAndColor: { texture: Nullable<BaseTexture>; color: Color4 } = { texture: null, color: new Color4() };\r\n    /** @internal */\r\n    public _effectIntensity: { [meshUniqueId: number]: number } = {};\r\n    /** @internal */\r\n    public _postProcesses: EffectWrapper[] = [];\r\n\r\n    /**\r\n     * Force all the effect layers to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the effect layer is enabled or not.\r\n     */\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets/sets the camera attached to the layer.\r\n     */\r\n    public get camera(): Nullable<Camera> {\r\n        return this._options.camera;\r\n    }\r\n\r\n    public set camera(camera: Nullable<Camera>) {\r\n        this._options.camera = camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._options.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._options.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderLayerObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the layer is being blurred.\r\n     */\r\n    public onBeforeBlurObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the layer has been blurred.\r\n     */\r\n    public onAfterBlurObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * Gets the object renderer used to render objects in the layer\r\n     */\r\n    public get objectRenderer() {\r\n        return this._objectRenderer;\r\n    }\r\n\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    private _materialForRendering: { [id: string]: [AbstractMesh, Material] } = {};\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._objectRenderer.setMaterialForRendering(mesh, material);\r\n        if (Array.isArray(mesh)) {\r\n            for (let i = 0; i < mesh.length; ++i) {\r\n                const currentMesh = mesh[i];\r\n                if (!material) {\r\n                    delete this._materialForRendering[currentMesh.uniqueId];\r\n                } else {\r\n                    this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\r\n                }\r\n            }\r\n        } else {\r\n            if (!material) {\r\n                delete this._materialForRendering[mesh.uniqueId];\r\n            } else {\r\n                this._materialForRendering[mesh.uniqueId] = [mesh, material];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to get the effect intensity for\r\n     * @returns The intensity of the effect for the mesh\r\n     */\r\n    public getEffectIntensity(mesh: AbstractMesh) {\r\n        return this._effectIntensity[mesh.uniqueId] ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to set the effect intensity for\r\n     * @param intensity The intensity of the effect for the mesh\r\n     */\r\n    public setEffectIntensity(mesh: AbstractMesh, intensity: number): void {\r\n        this._effectIntensity[mesh.uniqueId] = intensity;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.\r\n     * @param _additionalImportShadersAsync Additional shaders to import when the layer is created\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene?: Scene,\r\n        forceGLSL = false,\r\n        dontCheckIfReady = false,\r\n        private _additionalImportShadersAsync?: () => Promise<void>\r\n    ) {\r\n        this.name = name;\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        this._dontCheckIfReady = dontCheckIfReady;\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        if (engine.isWebGPU && !forceGLSL && !ThinEffectLayer.ForceGLSL) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n        }\r\n\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shadersLoaded = false;\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param _subMesh the mesh to check for\r\n     * @param _useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(_subMesh: SubMesh, _useInstances: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public needStencil(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createMergeEffect(): Effect {\r\n        throw new Error(\"Effect Layer: no merge effect defined\");\r\n    }\r\n\r\n    /** @internal */\r\n    public _createTextureAndPostProcesses(): void {}\r\n\r\n    /** @internal */\r\n    public bindTexturesForCompose: (effect: Effect) => void;\r\n\r\n    /** @internal */\r\n    public _internalCompose(_effect: Effect, _renderIndex: number): void {}\r\n\r\n    /** @internal */\r\n    public _setEmissiveTextureAndColor(_mesh: Mesh, _subMesh: SubMesh, _material: Material): void {}\r\n\r\n    /** @internal */\r\n    public _numInternalDraws(): number {\r\n        return 1;\r\n    }\r\n\r\n    /** @internal */\r\n    public _init(options: IThinEffectLayerOptions): void {\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            mainTextureFixedSize: 0,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        this._createObjectRenderer();\r\n    }\r\n\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    protected _createObjectRenderer(): void {\r\n        this._objectRenderer = new ObjectRenderer(`ObjectRenderer for thin effect layer ${this.name}`, this._scene, {\r\n            doNotChangeAspectRatio: true,\r\n        });\r\n        this._objectRenderer.activeCamera = this._options.camera;\r\n        this._objectRenderer.renderParticles = false;\r\n        this._objectRenderer.renderList = null;\r\n\r\n        // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\r\n        const hasBoundingBoxRenderer = !!this._scene.getBoundingBoxRenderer;\r\n\r\n        let boundingBoxRendererEnabled = false;\r\n        if (hasBoundingBoxRenderer) {\r\n            this._objectRenderer.onBeforeRenderObservable.add(() => {\r\n                boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n                this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n            });\r\n\r\n            this._objectRenderer.onAfterRenderObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n            });\r\n        }\r\n\r\n        this._objectRenderer.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n                    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n                    if (!this._isSubMeshReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        this._objectRenderer.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            this.onBeforeRenderLayerObservable.notifyObservers(this);\r\n\r\n            let index: number;\r\n\r\n            const engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                const subMesh = transparentSubMeshes.data[index];\r\n                const material = subMesh.getMaterial();\r\n                if (material && material.needDepthPrePass) {\r\n                    const engine = material.getScene().getEngine();\r\n                    engine.setColorWrite(false);\r\n                    this._renderSubMesh(subMesh);\r\n                    engine.setColorWrite(true);\r\n                }\r\n                this._renderSubMesh(subMesh, true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n    }\r\n\r\n    /** @internal */\r\n    public _addCustomEffectDefines(_defines: string[]): void {}\r\n\r\n    /** @internal */\r\n    public _internalIsSubMeshReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\r\n            return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\r\n        }\r\n\r\n        const defines: string[] = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n        const color = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTestingForMesh(mesh);\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse =\r\n                diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n                if (!diffuseTexture.gammaSpace) {\r\n                    defines.push(\"#define DIFFUSE_ISLINEAR\");\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n            if (!emissiveTexture.gammaSpace) {\r\n                defines.push(\"#define EMISSIVE_ISLINEAR\");\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const numMorphInfluencers = mesh.morphTargetManager\r\n            ? PrepareDefinesAndAttributesForMorphTargets(\r\n                  mesh.morphTargetManager,\r\n                  defines,\r\n                  attribs,\r\n                  mesh,\r\n                  true, // usePositionMorph\r\n                  false, // useNormalMorph\r\n                  false, // useTangentMorph\r\n                  uv1, // useUVMorph\r\n                  uv2, // useUV2Morph\r\n                  color // useColorMorph\r\n              )\r\n            : 0;\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // ClipPlanes\r\n        prepareStringDefinesForClipPlanes(material, this._scene, defines);\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines as string;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"viewProjection\",\r\n                \"glowColor\",\r\n                \"morphTargetInfluences\",\r\n                \"morphTargetCount\",\r\n                \"boneTextureWidth\",\r\n                \"diffuseMatrix\",\r\n                \"emissiveMatrix\",\r\n                \"opacityMatrix\",\r\n                \"opacityIntensity\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n                \"glowIntensity\",\r\n            ];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                this._engine.createEffect(\r\n                    \"glowMapGeneration\",\r\n                    attribs,\r\n                    uniforms,\r\n                    [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"],\r\n                    join,\r\n                    fallbacks,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                    this._shaderLanguage,\r\n                    this._shadersLoaded\r\n                        ? undefined\r\n                        : async () => {\r\n                              await this._importShadersAsync();\r\n                              this._shadersLoaded = true;\r\n                          }\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        const effectIsReady = drawWrapper.effect!.isReady();\r\n\r\n        return effectIsReady && (this._dontCheckIfReady || (!this._dontCheckIfReady && this.isLayerReady()));\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSubMeshReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        return this._internalIsSubMeshReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    protected async _importShadersAsync(): Promise<void> {\r\n        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([import(\"../ShadersWGSL/glowMapGeneration.vertex\"), import(\"../ShadersWGSL/glowMapGeneration.fragment\")]);\r\n        } else {\r\n            await Promise.all([import(\"../Shaders/glowMapGeneration.vertex\"), import(\"../Shaders/glowMapGeneration.fragment\")]);\r\n        }\r\n        this._additionalImportShadersAsync?.();\r\n    }\r\n\r\n    /** @internal */\r\n    public _internalIsLayerReady(): boolean {\r\n        let isReady = true;\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            isReady = this._postProcesses[i].isReady() && isReady;\r\n        }\r\n\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            let currentEffect = this._mergeDrawWrapper[i];\r\n            if (!currentEffect) {\r\n                currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\r\n                currentEffect.setEffect(this._createMergeEffect());\r\n            }\r\n            isReady = currentEffect.effect!.isReady() && isReady;\r\n        }\r\n\r\n        return isReady;\r\n    }\r\n\r\n    /**\r\n     * Checks if the layer is ready to be used.\r\n     * @returns true if the layer is ready to be used\r\n     */\r\n    public isLayerReady(): boolean {\r\n        return this._internalIsLayerReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     * @returns true if the rendering was successful\r\n     */\r\n    public compose(): boolean {\r\n        if (!this._dontCheckIfReady && !this.isLayerReady()) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        const previousAlphaMode = engine.getAlphaMode();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            const currentEffect = this._mergeDrawWrapper[i];\r\n\r\n            // Render\r\n            engine.enableEffect(currentEffect);\r\n            engine.setState(false);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect!);\r\n\r\n            // Go Blend.\r\n            engine.setAlphaMode(this._options.alphaBlendingMode);\r\n\r\n            // Blends the map on the main canvas.\r\n            this._internalCompose(currentEffect.effect!, i);\r\n        }\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _internalHasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        return this._internalHasMesh(mesh);\r\n    }\r\n\r\n    /** @internal */\r\n    public _internalShouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this._internalShouldRender();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRenderMesh(_mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _internalCanRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /** @internal */\r\n    public _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return this._internalCanRenderMesh(mesh, material);\r\n    }\r\n\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this._internalShouldRender()) {\r\n            return;\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = subMesh.getReplacementMesh();\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = subMesh.getEffectiveMesh();\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = material._getEffectiveOrientation(renderingMesh);\r\n        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\r\n\r\n        // Managing instances\r\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            subMesh.getMaterial()!._glowModeEnabled = true;\r\n            renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\r\n            subMesh.getMaterial()!._glowModeEnabled = false;\r\n        } else if (this._isSubMeshReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n            let drawWrapper = subMesh._getDrawWrapper();\r\n            if (!drawWrapper && renderingMaterial) {\r\n                drawWrapper = renderingMaterial._getDrawWrapper();\r\n            }\r\n\r\n            if (!drawWrapper) {\r\n                return;\r\n            }\r\n\r\n            const effect = drawWrapper.effect!;\r\n\r\n            engine.enableEffect(drawWrapper);\r\n            if (!hardwareInstancedRendering) {\r\n                renderingMesh._bind(subMesh, effect, material.fillMode);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                effect.setFloat4(\r\n                    \"glowColor\",\r\n                    this._emissiveTextureAndColor.color.r,\r\n                    this._emissiveTextureAndColor.color.g,\r\n                    this._emissiveTextureAndColor.color.b,\r\n                    this._emissiveTextureAndColor.color.a\r\n                );\r\n            } else {\r\n                renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                const needAlphaTest = material.needAlphaTestingForMesh(effectiveMesh);\r\n\r\n                const diffuseTexture = material.getAlphaTestTexture();\r\n                const needAlphaBlendFromDiffuse =\r\n                    diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n                if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                    effect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                    const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                const opacityTexture = (material as any).opacityTexture;\r\n                if (opacityTexture) {\r\n                    effect.setTexture(\"opacitySampler\", opacityTexture);\r\n                    effect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                    const textureMatrix = opacityTexture.getTextureMatrix();\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                // Glow emissive only\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                    effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    const skeleton = renderingMesh.skeleton;\r\n\r\n                    if (skeleton.isUsingTextureForMatrices) {\r\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                        if (!boneTexture) {\r\n                            return;\r\n                        }\r\n\r\n                        effect.setTexture(\"boneSampler\", boneTexture);\r\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                    } else {\r\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Alpha mode\r\n                if (enableAlphaMode) {\r\n                    engine.setAlphaMode(material.alphaMode);\r\n                }\r\n\r\n                // Intensity of effect\r\n                effect.setFloat(\"glowIntensity\", this.getEffectIntensity(renderingMesh));\r\n\r\n                // Clip planes\r\n                bindClipPlane(effect, material, scene);\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                effect.setMatrix(\"world\", world)\r\n            );\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._objectRenderer.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /** @internal */\r\n    public _useMeshMaterial(_mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose the effect layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        for (const drawWrapper of this._mergeDrawWrapper) {\r\n            drawWrapper.dispose();\r\n        }\r\n        this._mergeDrawWrapper = [];\r\n\r\n        this._objectRenderer.dispose();\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderLayerObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n    }\r\n}\r\n", "import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { GetExponentOfTwo } from \"../Misc/tools.functions\";\r\nimport type { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { ThinEffectLayer } from \"./thinEffectLayer\";\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation. Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_BYTE\r\n     */\r\n    mainTextureType: number;\r\n\r\n    /**\r\n     * Whether or not to generate a stencil buffer. Default: false\r\n     */\r\n    generateStencilBuffer: boolean;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or highlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: AbstractEngine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected get _shouldRender() {\r\n        return this._thinEffectLayer._shouldRender;\r\n    }\r\n    protected set _shouldRender(value) {\r\n        this._thinEffectLayer._shouldRender = value;\r\n    }\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected get _emissiveTextureAndColor(): { texture: Nullable<BaseTexture>; color: Color4 } {\r\n        return this._thinEffectLayer._emissiveTextureAndColor;\r\n    }\r\n    protected set _emissiveTextureAndColor(value) {\r\n        this._thinEffectLayer._emissiveTextureAndColor = value;\r\n    }\r\n    protected get _effectIntensity(): { [meshUniqueId: number]: number } {\r\n        return this._thinEffectLayer._effectIntensity;\r\n    }\r\n    protected set _effectIntensity(value) {\r\n        this._thinEffectLayer._effectIntensity = value;\r\n    }\r\n    protected readonly _thinEffectLayer: ThinEffectLayer;\r\n    private readonly _internalThinEffectLayer: boolean;\r\n\r\n    /**\r\n     * Force all the effect layers to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static get ForceGLSL() {\r\n        return ThinEffectLayer.ForceGLSL;\r\n    }\r\n\r\n    public static set ForceGLSL(value: boolean) {\r\n        ThinEffectLayer.ForceGLSL = value;\r\n    }\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public get name() {\r\n        return this._thinEffectLayer.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._thinEffectLayer.name = value;\r\n    }\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public get neutralColor(): Color4 {\r\n        return this._thinEffectLayer.neutralColor;\r\n    }\r\n\r\n    public set neutralColor(value: Color4) {\r\n        this._thinEffectLayer.neutralColor = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public get isEnabled(): boolean {\r\n        return this._thinEffectLayer.isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        this._thinEffectLayer.isEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._thinEffectLayer.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._thinEffectLayer.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._thinEffectLayer.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public get disableBoundingBoxesFromEffectLayer() {\r\n        return this._thinEffectLayer.disableBoundingBoxesFromEffectLayer;\r\n    }\r\n\r\n    public set disableBoundingBoxesFromEffectLayer(value: boolean) {\r\n        this._thinEffectLayer.disableBoundingBoxesFromEffectLayer = value;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * Gets the main texture where the effect is rendered\r\n     */\r\n    public get mainTexture() {\r\n        return this._mainTexture;\r\n    }\r\n\r\n    protected get _shaderLanguage(): ShaderLanguage {\r\n        return this._thinEffectLayer.shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._thinEffectLayer.shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"EffectLayerSceneComponent\");\r\n    };\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._thinEffectLayer.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to get the effect intensity for\r\n     * @returns The intensity of the effect for the mesh\r\n     */\r\n    public getEffectIntensity(mesh: AbstractMesh) {\r\n        return this._thinEffectLayer.getEffectIntensity(mesh);\r\n    }\r\n\r\n    /**\r\n     * Sets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to set the effect intensity for\r\n     * @param intensity The intensity of the effect for the mesh\r\n     */\r\n    public setEffectIntensity(mesh: AbstractMesh, intensity: number): void {\r\n        this._thinEffectLayer.setEffectIntensity(mesh, intensity);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     * @param thinEffectLayer The thin instance of the effect layer (optional)\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene?: Scene,\r\n        forceGLSL = false,\r\n        thinEffectLayer?: ThinEffectLayer\r\n    ) {\r\n        this._internalThinEffectLayer = !thinEffectLayer;\r\n        if (!thinEffectLayer) {\r\n            thinEffectLayer = new ThinEffectLayer(name, scene, forceGLSL, false, this._importShadersAsync.bind(this));\r\n            thinEffectLayer.getEffectName = this.getEffectName.bind(this);\r\n            thinEffectLayer.isReady = this.isReady.bind(this);\r\n            thinEffectLayer._createMergeEffect = this._createMergeEffect.bind(this);\r\n            thinEffectLayer._createTextureAndPostProcesses = this._createTextureAndPostProcesses.bind(this);\r\n            thinEffectLayer._internalCompose = this._internalRender.bind(this);\r\n            thinEffectLayer._setEmissiveTextureAndColor = this._setEmissiveTextureAndColor.bind(this);\r\n            thinEffectLayer._numInternalDraws = this._numInternalDraws.bind(this);\r\n            thinEffectLayer._addCustomEffectDefines = this._addCustomEffectDefines.bind(this);\r\n            thinEffectLayer.hasMesh = this.hasMesh.bind(this);\r\n            thinEffectLayer.shouldRender = this.shouldRender.bind(this);\r\n            thinEffectLayer._shouldRenderMesh = this._shouldRenderMesh.bind(this);\r\n            thinEffectLayer._canRenderMesh = this._canRenderMesh.bind(this);\r\n            thinEffectLayer._useMeshMaterial = this._useMeshMaterial.bind(this);\r\n        }\r\n\r\n        this._thinEffectLayer = thinEffectLayer;\r\n        this.name = name;\r\n\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.effectLayers.push(this);\r\n\r\n        this._thinEffectLayer.onDisposeObservable.add(() => {\r\n            this.onDisposeObservable.notifyObservers(this);\r\n        });\r\n\r\n        this._thinEffectLayer.onBeforeRenderLayerObservable.add(() => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n        });\r\n\r\n        this._thinEffectLayer.onBeforeComposeObservable.add(() => {\r\n            this.onBeforeComposeObservable.notifyObservers(this);\r\n        });\r\n\r\n        this._thinEffectLayer.onBeforeRenderMeshToEffect.add((mesh) => {\r\n            this.onBeforeRenderMeshToEffect.notifyObservers(mesh);\r\n        });\r\n\r\n        this._thinEffectLayer.onAfterRenderMeshToEffect.add((mesh) => {\r\n            this.onAfterRenderMeshToEffect.notifyObservers(mesh);\r\n        });\r\n\r\n        this._thinEffectLayer.onAfterComposeObservable.add(() => {\r\n            this.onAfterComposeObservable.notifyObservers(this);\r\n        });\r\n    }\r\n\r\n    protected get _shadersLoaded() {\r\n        return this._thinEffectLayer._shadersLoaded;\r\n    }\r\n\r\n    protected set _shadersLoaded(value: boolean) {\r\n        this._thinEffectLayer._shadersLoaded = value;\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderNum Index of the _internalRender call (0 for the first time _internalRender is called, 1 for the second time, etc. _internalRender is called the number of times returned by _numInternalDraws())\r\n     */\r\n    protected abstract _internalRender(effect: Effect, renderIndex: number): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\r\n     * @returns Number of times a mesh must be rendered in the layer\r\n     */\r\n    protected _numInternalDraws(): number {\r\n        return this._internalThinEffectLayer ? 1 : this._thinEffectLayer._numInternalDraws();\r\n    }\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            generateStencilBuffer: false,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._thinEffectLayer._init(options);\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        } else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures\r\n                ? GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize)\r\n                : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures\r\n                ? GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize)\r\n                : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\r\n            \"EffectLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height,\r\n            },\r\n            this._scene,\r\n            {\r\n                type: this._effectLayerOptions.mainTextureType,\r\n                samplingMode: Texture.TRILINEAR_SAMPLINGMODE,\r\n                generateStencilBuffer: this._effectLayerOptions.generateStencilBuffer,\r\n                existingObjectRenderer: this._thinEffectLayer.objectRenderer,\r\n            }\r\n        );\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        this._mainTexture.onClearObservable.add((engine: AbstractEngine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        return this._internalThinEffectLayer\r\n            ? this._thinEffectLayer._internalIsSubMeshReady(subMesh, useInstances, emissiveTexture)\r\n            : this._thinEffectLayer._isSubMeshReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    protected async _importShadersAsync(): Promise<void> {}\r\n\r\n    protected _arePostProcessAndMergeReady(): boolean {\r\n        return this._internalThinEffectLayer ? this._thinEffectLayer._internalIsLayerReady() : this._thinEffectLayer.isLayerReady();\r\n    }\r\n\r\n    /**\r\n     * Checks if the layer is ready to be used.\r\n     * @returns true if the layer is ready to be used\r\n     */\r\n    public isLayerReady(): boolean {\r\n        return this._arePostProcessAndMergeReady() && this._mainTexture.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        if (!this._thinEffectLayer.compose()) {\r\n            return;\r\n        }\r\n\r\n        // Handle size changes.\r\n        const size = this._mainTexture.getSize();\r\n        this._setMainTextureSize();\r\n        if (\r\n            (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) &&\r\n            this._mainTextureDesiredSize.width !== 0 &&\r\n            this._mainTextureDesiredSize.height !== 0\r\n        ) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        return this._internalThinEffectLayer ? this._thinEffectLayer._internalHasMesh(mesh) : this._thinEffectLayer.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this._internalThinEffectLayer ? this._thinEffectLayer._internalShouldRender() : this._thinEffectLayer.shouldRender();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return this._internalThinEffectLayer ? true : this._thinEffectLayer._shouldRenderMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return this._internalThinEffectLayer ? this._thinEffectLayer._internalCanRenderMesh(mesh, material) : this._thinEffectLayer._canRenderMesh(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     * @returns true if the mesh material should be use\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return this._internalThinEffectLayer ? false : this._thinEffectLayer._useMeshMaterial(mesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @internal Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        this._thinEffectLayer._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (let i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        this._thinEffectLayer.dispose();\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        const index = this._scene.effectLayers.indexOf(this, 0);\r\n        if (index > -1) {\r\n            this._scene.effectLayers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n", "import type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Stores the list of available parsers in the application.\r\n */\r\nconst _BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n/**\r\n * Stores the list of available individual parsers in the application.\r\n */\r\nconst _IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n/**\r\n * Adds a parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddParser(name: string, parser: BabylonFileParser): void {\r\n    _BabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets a general parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetParser(name: string): Nullable<BabylonFileParser> {\r\n    if (_BabylonFileParsers[name]) {\r\n        return _BabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Adds n individual parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n    _IndividualBabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets an individual parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n    if (_IndividualBabylonFileParsers[name]) {\r\n        return _IndividualBabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Parser json data and populate both a scene and its associated container object\r\n * @param jsonData Defines the data to parse\r\n * @param scene Defines the scene to parse the data for\r\n * @param container Defines the container attached to the parsing sequence\r\n * @param rootUrl Defines the root url of the data\r\n */\r\nexport function Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n    for (const parserName in _BabylonFileParsers) {\r\n        if (Object.prototype.hasOwnProperty.call(_BabylonFileParsers, parserName)) {\r\n            _BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n        }\r\n    }\r\n}\r\n", "import { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n// Adds the parser to the scene parsers.\r\nAddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    if (parsedData.effectLayers) {\r\n        if (!container.effectLayers) {\r\n            container.effectLayers = [] as EffectLayer[];\r\n        }\r\n\r\n        for (let index = 0; index < parsedData.effectLayers.length; index++) {\r\n            const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\r\n            container.effectLayers.push(effectLayer);\r\n        }\r\n    }\r\n});\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /**\r\n         * Removes the given effect layer from this scene.\r\n         * @param toRemove defines the effect layer to remove\r\n         * @returns the index of the removed effect layer\r\n         */\r\n        removeEffectLayer(toRemove: EffectLayer): number;\r\n\r\n        /**\r\n         * Adds the given effect layer to this scene\r\n         * @param newEffectLayer defines the effect layer to add\r\n         */\r\n        addEffectLayer(newEffectLayer: EffectLayer): void;\r\n    }\r\n}\r\n\r\nScene.prototype.removeEffectLayer = function (toRemove: EffectLayer): number {\r\n    const index = this.effectLayers.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.effectLayers.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nScene.prototype.addEffectLayer = function (newEffectLayer: EffectLayer): void {\r\n    this.effectLayers.push(newEffectLayer);\r\n};\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\r\nexport class EffectLayerSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_EFFECTLAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: AbstractEngine;\r\n    private _renderEffects = false;\r\n    private _needStencil = false;\r\n    private _previousStencilState = false;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\r\n\r\n        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\r\n\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\r\n\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            effectLayer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Effect layers\r\n        serializationObject.effectLayers = [];\r\n\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            if (effectLayer.serialize) {\r\n                serializationObject.effectLayers.push(effectLayer.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: IAssetContainer): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.addEffectLayer(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: IAssetContainer, dispose?: boolean): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.removeEffectLayer(o);\r\n            if (dispose) {\r\n                o.dispose();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.effectLayers;\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _isReadyForMesh(mesh: AbstractMesh, hardwareInstancedRendering: boolean): boolean {\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n        const layers = this.scene.effectLayers;\r\n        for (const layer of layers) {\r\n            if (!layer.hasMesh(mesh)) {\r\n                continue;\r\n            }\r\n\r\n            const renderTarget = <RenderTargetTexture>(<any>layer)._mainTexture;\r\n            this._engine.currentRenderPassId = renderTarget.renderPassId;\r\n\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\r\n                    this._engine.currentRenderPassId = currentRenderPassId;\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n        return true;\r\n    }\r\n\r\n    private _renderMainTexture(camera: Camera): boolean {\r\n        this._renderEffects = false;\r\n        this._needStencil = false;\r\n\r\n        let needRebind = false;\r\n\r\n        const layers = this.scene.effectLayers;\r\n        if (layers && layers.length > 0) {\r\n            this._previousStencilState = this._engine.getStencilBuffer();\r\n            for (const effectLayer of layers) {\r\n                if (\r\n                    effectLayer.shouldRender() &&\r\n                    (!effectLayer.camera ||\r\n                        (effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera) ||\r\n                        (effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1))\r\n                ) {\r\n                    this._renderEffects = true;\r\n                    this._needStencil = this._needStencil || effectLayer.needStencil();\r\n\r\n                    const renderTarget = <RenderTargetTexture>(<any>effectLayer)._mainTexture;\r\n                    if (renderTarget._shouldRender()) {\r\n                        this.scene.incrementRenderId();\r\n                        renderTarget.render(false, false);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.scene.incrementRenderId();\r\n        }\r\n\r\n        return needRebind;\r\n    }\r\n\r\n    private _setStencil() {\r\n        // Activate effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _setStencilBack() {\r\n        // Restore effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(this._previousStencilState);\r\n        }\r\n    }\r\n\r\n    private _draw(renderingGroupId: number): void {\r\n        if (this._renderEffects) {\r\n            this._engine.setDepthBuffer(false);\r\n\r\n            const layers = this.scene.effectLayers;\r\n            for (let i = 0; i < layers.length; i++) {\r\n                const effectLayer = layers[i];\r\n                if (effectLayer.renderingGroupId === renderingGroupId) {\r\n                    if (effectLayer.shouldRender()) {\r\n                        effectLayer.render();\r\n                    }\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCamera(): void {\r\n        if (this._renderEffects) {\r\n            this._draw(-1);\r\n        }\r\n    }\r\n    private _drawRenderingGroup(index: number): void {\r\n        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\r\n            this._draw(index);\r\n        }\r\n    }\r\n}\r\n\r\nEffectLayer._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER) as EffectLayerSceneComponent;\r\n    if (!component) {\r\n        component = new EffectLayerSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ThinEffectLayer } from \"./thinEffectLayer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { PBRMaterial } from \"../Materials/PBR/pbrMaterial\";\r\n\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { IThinEffectLayerOptions } from \"./thinEffectLayer\";\r\nimport { ThinBlurPostProcess } from \"core/PostProcesses/thinBlurPostProcess\";\r\n\r\n/**\r\n * Glow layer options. This helps customizing the behaviour\r\n * of the glow layer.\r\n */\r\nexport interface IThinGlowLayerOptions extends IThinEffectLayerOptions {\r\n    /**\r\n     * How big is the kernel of the blur texture. Default: 32\r\n     */\r\n    blurKernelSize?: number;\r\n\r\n    /**\r\n     * Forces the merge step to be done in ldr (clamp values > 1). Default: false\r\n     */\r\n    ldrMerge?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinGlowLayer extends ThinEffectLayer {\r\n    /**\r\n     * Effect Name of the layer.\r\n     */\r\n    public static readonly EffectName = \"GlowLayer\";\r\n\r\n    /**\r\n     * The default blur kernel size used for the glow.\r\n     */\r\n    public static DefaultBlurKernelSize = 32;\r\n\r\n    /**\r\n     * Gets the ldrMerge option.\r\n     */\r\n    public get ldrMerge(): boolean {\r\n        return this._options.ldrMerge;\r\n    }\r\n\r\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\r\n    public set blurKernelSize(value: number) {\r\n        if (value === this._options.blurKernelSize) {\r\n            return;\r\n        }\r\n\r\n        this._options.blurKernelSize = value;\r\n\r\n        const effectiveKernel = this._getEffectiveBlurKernelSize();\r\n        this._horizontalBlurPostprocess1.kernel = effectiveKernel;\r\n        this._verticalBlurPostprocess1.kernel = effectiveKernel;\r\n        this._horizontalBlurPostprocess2.kernel = effectiveKernel;\r\n        this._verticalBlurPostprocess2.kernel = effectiveKernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\r\n    public get blurKernelSize(): number {\r\n        return this._options.blurKernelSize;\r\n    }\r\n\r\n    /**\r\n     * Sets the glow intensity.\r\n     */\r\n    public set intensity(value: number) {\r\n        this._intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow intensity.\r\n     */\r\n    public get intensity(): number {\r\n        return this._intensity;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _options: Required<IThinGlowLayerOptions>;\r\n\r\n    private _intensity: number = 1.0;\r\n    private _horizontalBlurPostprocess1: ThinBlurPostProcess;\r\n    private _verticalBlurPostprocess1: ThinBlurPostProcess;\r\n    private _horizontalBlurPostprocess2: ThinBlurPostProcess;\r\n    private _verticalBlurPostprocess2: ThinBlurPostProcess;\r\n\r\n    /** @internal */\r\n    public _includedOnlyMeshes: number[] = [];\r\n    /** @internal */\r\n    public _excludedMeshes: number[] = [];\r\n    private _meshesUsingTheirOwnMaterials: number[] = [];\r\n\r\n    /**\r\n     * Callback used to let the user override the color selection on a per mesh basis\r\n     */\r\n    public customEmissiveColorSelector: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void;\r\n    /**\r\n     * Callback used to let the user override the texture selection on a per mesh basis\r\n     */\r\n    public customEmissiveTextureSelector: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture;\r\n\r\n    /** @internal */\r\n    public _renderPassId = 0;\r\n\r\n    /**\r\n     * Instantiates a new glow Layer and references it to the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n     * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: IThinGlowLayerOptions, dontCheckIfReady = false) {\r\n        super(name, scene, false, dontCheckIfReady);\r\n        this.neutralColor = new Color4(0, 0, 0, 1);\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            mainTextureFixedSize: 0,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            blurKernelSize: 32,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ldrMerge: false,\r\n            alphaBlendingMode: Constants.ALPHA_ADD,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init(this._options);\r\n\r\n        if (dontCheckIfReady) {\r\n            // When dontCheckIfReady is true, we are in the new ThinXXX layer mode, so we must call _createTextureAndPostProcesses ourselves (it is called by EffectLayer otherwise)\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the thin glow layer\r\n     * @returns the string with the class name of the glow layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"GlowLayer\";\r\n    }\r\n\r\n    protected override async _importShadersAsync() {\r\n        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../ShadersWGSL/glowMapMerge.fragment\"),\r\n                import(\"../ShadersWGSL/glowMapMerge.vertex\"),\r\n                import(\"../ShadersWGSL/glowBlurPostProcess.fragment\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([import(\"../Shaders/glowMapMerge.fragment\"), import(\"../Shaders/glowMapMerge.vertex\"), import(\"../Shaders/glowBlurPostProcess.fragment\")]);\r\n        }\r\n\r\n        await super._importShadersAsync();\r\n    }\r\n\r\n    public override getEffectName(): string {\r\n        return ThinGlowLayer.EffectName;\r\n    }\r\n\r\n    public override _createMergeEffect(): Effect {\r\n        let defines = \"#define EMISSIVE \\n\";\r\n        if (this._options.ldrMerge) {\r\n            defines += \"#define LDR \\n\";\r\n        }\r\n\r\n        // Effect\r\n        return this._engine.createEffect(\r\n            \"glowMapMerge\",\r\n            [VertexBuffer.PositionKind],\r\n            [\"offset\"],\r\n            [\"textureSampler\", \"textureSampler2\"],\r\n            defines,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this.shaderLanguage,\r\n            this._shadersLoaded\r\n                ? undefined\r\n                : async () => {\r\n                      await this._importShadersAsync();\r\n                      this._shadersLoaded = true;\r\n                  }\r\n        );\r\n    }\r\n\r\n    public override _createTextureAndPostProcesses(): void {\r\n        const effectiveKernel = this._getEffectiveBlurKernelSize();\r\n        this._horizontalBlurPostprocess1 = new ThinBlurPostProcess(\"GlowLayerHBP1\", this._scene.getEngine(), new Vector2(1.0, 0), effectiveKernel);\r\n        this._verticalBlurPostprocess1 = new ThinBlurPostProcess(\"GlowLayerVBP1\", this._scene.getEngine(), new Vector2(0, 1.0), effectiveKernel);\r\n\r\n        this._horizontalBlurPostprocess2 = new ThinBlurPostProcess(\"GlowLayerHBP2\", this._scene.getEngine(), new Vector2(1.0, 0), effectiveKernel);\r\n        this._verticalBlurPostprocess2 = new ThinBlurPostProcess(\"GlowLayerVBP2\", this._scene.getEngine(), new Vector2(0, 1.0), effectiveKernel);\r\n\r\n        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n    }\r\n\r\n    private _getEffectiveBlurKernelSize() {\r\n        return this._options.blurKernelSize / 2;\r\n    }\r\n\r\n    public override isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh) {\r\n            return false;\r\n        }\r\n\r\n        const emissiveTexture = (<any>material).emissiveTexture;\r\n        return super._isSubMeshReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    public override _canRenderMesh(_mesh: AbstractMesh, _material: Material): boolean {\r\n        return true;\r\n    }\r\n\r\n    public override _internalCompose(effect: Effect): void {\r\n        // Texture\r\n        this.bindTexturesForCompose(effect);\r\n        effect.setFloat(\"offset\", this._intensity);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        const previousStencilBuffer = engine.getStencilBuffer();\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(false);\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(previousStencilBuffer);\r\n    }\r\n\r\n    public override _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        let textureLevel = 1.0;\r\n\r\n        if (this.customEmissiveTextureSelector) {\r\n            this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\r\n        } else {\r\n            if (material) {\r\n                this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    textureLevel = this._emissiveTextureAndColor.texture.level;\r\n                }\r\n            } else {\r\n                this._emissiveTextureAndColor.texture = null;\r\n            }\r\n        }\r\n\r\n        if (this.customEmissiveColorSelector) {\r\n            this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\r\n        } else {\r\n            if ((<any>material).emissiveColor) {\r\n                const emissiveIntensity = (<PBRMaterial>material).emissiveIntensity ?? 1;\r\n                textureLevel *= emissiveIntensity;\r\n                this._emissiveTextureAndColor.color.set(\r\n                    (<any>material).emissiveColor.r * textureLevel,\r\n                    (<any>material).emissiveColor.g * textureLevel,\r\n                    (<any>material).emissiveColor.b * textureLevel,\r\n                    material.alpha\r\n                );\r\n            } else {\r\n                this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this.hasMesh(mesh);\r\n    }\r\n\r\n    public override _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define GLOW\");\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to exclude from the glow layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh): void {\r\n        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._excludedMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh): void {\r\n        const index = this._excludedMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._excludedMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to include in the glow layer\r\n     */\r\n    public addIncludedOnlyMesh(mesh: Mesh): void {\r\n        if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._includedOnlyMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeIncludedOnlyMesh(mesh: Mesh): void {\r\n        const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._includedOnlyMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    public override hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        // Included Mesh\r\n        if (this._includedOnlyMeshes.length) {\r\n            return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\r\n        }\r\n\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes.length) {\r\n            return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        // Specific case of material supporting glow directly\r\n        if (mesh.material?._supportGlowLayer) {\r\n            return true;\r\n        }\r\n\r\n        if (this._meshesUsingTheirOwnMaterials.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to be rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to use its material\r\n     */\r\n    public referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void {\r\n        mesh.resetDrawCache(this._renderPassId);\r\n\r\n        this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\r\n\r\n        mesh.onDisposeObservable.add(() => {\r\n            this._disposeMesh(mesh as Mesh);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from being rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to not use its material\r\n     * @param renderPassId The render pass id used when rendering the mesh\r\n     */\r\n    public unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh, renderPassId: number): void {\r\n        let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        while (index >= 0) {\r\n            this._meshesUsingTheirOwnMaterials.splice(index, 1);\r\n            index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        }\r\n        mesh.resetDrawCache(renderPassId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeIncludedOnlyMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport type { IThinGlowLayerOptions } from \"./thinGlowLayer\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\n\r\nimport \"../Layers/effectLayerSceneComponent\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { GetExponentOfTwo } from \"../Misc/tools.functions\";\r\nimport { ThinGlowLayer } from \"./thinGlowLayer\";\r\nimport type { ThinBlurPostProcess } from \"core/PostProcesses/thinBlurPostProcess\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /**\r\n         * Return the first glow layer of the scene with a given name.\r\n         * @param name The name of the glow layer to look for.\r\n         * @returns The glow layer if found otherwise null.\r\n         */\r\n        getGlowLayerByName(name: string): Nullable<GlowLayer>;\r\n    }\r\n}\r\n\r\nScene.prototype.getGlowLayerByName = function (name: string): Nullable<GlowLayer> {\r\n    for (let index = 0; index < this.effectLayers?.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as GlowLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Glow layer options. This helps customizing the behaviour\r\n * of the glow layer.\r\n */\r\nexport interface IGlowLayerOptions extends IThinGlowLayerOptions {\r\n    /**\r\n     * Enable MSAA by choosing the number of samples. Default: 1\r\n     */\r\n    mainTextureSamples?: number;\r\n\r\n    /**\r\n     * Whether or not to generate a stencil buffer. Default: false\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n}\r\n\r\n/**\r\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\r\n *\r\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\r\n *\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\r\n */\r\nexport class GlowLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the layer.\r\n     */\r\n    public static get EffectName() {\r\n        return ThinGlowLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * The default blur kernel size used for the glow.\r\n     */\r\n    public static DefaultBlurKernelSize = 32;\r\n\r\n    /**\r\n     * The default texture size ratio used for the glow.\r\n     */\r\n    public static DefaultTextureRatio = 0.5;\r\n\r\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\r\n    public set blurKernelSize(value: number) {\r\n        this._thinEffectLayer.blurKernelSize = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurKernelSize(): number {\r\n        return this._thinEffectLayer.blurKernelSize;\r\n    }\r\n\r\n    /**\r\n     * Sets the glow intensity.\r\n     */\r\n    public set intensity(value: number) {\r\n        this._thinEffectLayer.intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow intensity.\r\n     */\r\n    @serialize()\r\n    public get intensity(): number {\r\n        return this._thinEffectLayer.intensity;\r\n    }\r\n\r\n    @serialize(\"options\")\r\n    protected _options: IGlowLayerOptions;\r\n\r\n    protected override readonly _thinEffectLayer: ThinGlowLayer;\r\n    private _horizontalBlurPostprocess1: BlurPostProcess;\r\n    private _verticalBlurPostprocess1: BlurPostProcess;\r\n    private _horizontalBlurPostprocess2: BlurPostProcess;\r\n    private _verticalBlurPostprocess2: BlurPostProcess;\r\n    private _blurTexture1: RenderTargetTexture;\r\n    private _blurTexture2: RenderTargetTexture;\r\n    private _postProcesses1: PostProcess[];\r\n    private _postProcesses2: PostProcess[];\r\n    /**\r\n     * Callback used to let the user override the color selection on a per mesh basis\r\n     */\r\n    public get customEmissiveColorSelector(): (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void {\r\n        return this._thinEffectLayer.customEmissiveColorSelector;\r\n    }\r\n\r\n    public set customEmissiveColorSelector(value: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void) {\r\n        this._thinEffectLayer.customEmissiveColorSelector = value;\r\n    }\r\n\r\n    /**\r\n     * Callback used to let the user override the texture selection on a per mesh basis\r\n     */\r\n    public get customEmissiveTextureSelector(): (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture {\r\n        return this._thinEffectLayer.customEmissiveTextureSelector;\r\n    }\r\n\r\n    public set customEmissiveTextureSelector(value: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture) {\r\n        this._thinEffectLayer.customEmissiveTextureSelector = value;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new glow Layer and references it to the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: Partial<IGlowLayerOptions>) {\r\n        super(name, scene, false, new ThinGlowLayer(name, scene, options));\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: GlowLayer.DefaultTextureRatio,\r\n            blurKernelSize: 32,\r\n            mainTextureFixedSize: undefined,\r\n            camera: null,\r\n            mainTextureSamples: 1,\r\n            renderingGroupId: -1,\r\n            ldrMerge: false,\r\n            alphaBlendingMode: Constants.ALPHA_ADD,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            generateStencilBuffer: false,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init(this._options);\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return GlowLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        return this._thinEffectLayer._createMergeEffect();\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the glow layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        this._thinEffectLayer._renderPassId = this._mainTexture.renderPassId;\r\n\r\n        let blurTextureWidth = this._mainTextureDesiredSize.width;\r\n        let blurTextureHeight = this._mainTextureDesiredSize.height;\r\n        blurTextureWidth = this._engine.needPOTTextures ? GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n\r\n        this._blurTexture1 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture1.renderParticles = false;\r\n        this._blurTexture1.ignoreCameraViewport = true;\r\n\r\n        const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\r\n        const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\r\n\r\n        this._blurTexture2 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT2\",\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture2.renderParticles = false;\r\n        this._blurTexture2.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture1, this._blurTexture2];\r\n\r\n        this._thinEffectLayer.bindTexturesForCompose = (effect: Effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n            effect.setTexture(\"textureSampler2\", this._blurTexture2);\r\n            effect.setFloat(\"offset\", this.intensity);\r\n        };\r\n\r\n        this._thinEffectLayer._createTextureAndPostProcesses();\r\n\r\n        const thinBlurPostProcesses1 = this._thinEffectLayer._postProcesses[0] as ThinBlurPostProcess;\r\n        this._horizontalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerHBP1\", thinBlurPostProcesses1.direction, thinBlurPostProcesses1.kernel, {\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine: this._scene.getEngine(),\r\n            width: blurTextureWidth,\r\n            height: blurTextureHeight,\r\n            textureType,\r\n            effectWrapper: thinBlurPostProcesses1,\r\n        });\r\n        this._horizontalBlurPostprocess1.width = blurTextureWidth;\r\n        this._horizontalBlurPostprocess1.height = blurTextureHeight;\r\n        this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess1.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._mainTexture);\r\n        });\r\n\r\n        const thinBlurPostProcesses2 = this._thinEffectLayer._postProcesses[1] as ThinBlurPostProcess;\r\n        this._verticalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerVBP1\", thinBlurPostProcesses2.direction, thinBlurPostProcesses2.kernel, {\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine: this._scene.getEngine(),\r\n            width: blurTextureWidth,\r\n            height: blurTextureHeight,\r\n            textureType,\r\n            effectWrapper: thinBlurPostProcesses2,\r\n        });\r\n\r\n        const thinBlurPostProcesses3 = this._thinEffectLayer._postProcesses[2] as ThinBlurPostProcess;\r\n        this._horizontalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerHBP2\", thinBlurPostProcesses3.direction, thinBlurPostProcesses3.kernel, {\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine: this._scene.getEngine(),\r\n            width: blurTextureWidth2,\r\n            height: blurTextureHeight2,\r\n            textureType,\r\n            effectWrapper: thinBlurPostProcesses3,\r\n        });\r\n        this._horizontalBlurPostprocess2.width = blurTextureWidth2;\r\n        this._horizontalBlurPostprocess2.height = blurTextureHeight2;\r\n        this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess2.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        });\r\n\r\n        const thinBlurPostProcesses4 = this._thinEffectLayer._postProcesses[3] as ThinBlurPostProcess;\r\n        this._verticalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerVBP2\", thinBlurPostProcesses4.direction, thinBlurPostProcesses4.kernel, {\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine: this._scene.getEngine(),\r\n            width: blurTextureWidth2,\r\n            height: blurTextureHeight2,\r\n            textureType,\r\n            effectWrapper: thinBlurPostProcesses4,\r\n        });\r\n\r\n        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n        this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\r\n        this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n\r\n        this._mainTexture.samples = this._options.mainTextureSamples!;\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            const internalTexture = this._blurTexture1.renderTarget;\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);\r\n\r\n                const internalTexture2 = this._blurTexture2.renderTarget;\r\n                if (internalTexture2) {\r\n                    this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);\r\n                }\r\n                this._engine.unBindFramebuffer(internalTexture2 ?? internalTexture, true);\r\n            }\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => {\r\n            pp.autoClear = false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        return this._thinEffectLayer.isReady(subMesh, useInstances);\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected override _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return this._thinEffectLayer._canRenderMesh(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected _internalRender(effect: Effect): void {\r\n        this._thinEffectLayer._internalCompose(effect);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        this._thinEffectLayer._setEmissiveTextureAndColor(mesh, subMesh, material);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected override _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this._thinEffectLayer._shouldRenderMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected override _addCustomEffectDefines(defines: string[]): void {\r\n        this._thinEffectLayer._addCustomEffectDefines(defines);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to exclude from the glow layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer.addExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to include in the glow layer\r\n     */\r\n    public addIncludedOnlyMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer.addIncludedOnlyMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeIncludedOnlyMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer.removeIncludedOnlyMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the glow layer\r\n     * @param mesh The mesh to test\r\n     * @returns true if the mesh will be highlighted by the current glow layer\r\n     */\r\n    public override hasMesh(mesh: AbstractMesh): boolean {\r\n        return this._thinEffectLayer.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     * @returns true if the material of the mesh should be use to render the effect\r\n     */\r\n    protected override _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return this._thinEffectLayer._useMeshMaterial(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to be rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to use its material\r\n     */\r\n    public referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void {\r\n        this._thinEffectLayer.referenceMeshToUseItsOwnMaterial(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from being rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to not use its material\r\n     */\r\n    public unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh): void {\r\n        this._thinEffectLayer.unReferenceMeshFromUsingItsOwnMaterial(mesh, this._mainTexture.renderPassId);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @internal\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer._disposeMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GlowLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this glow layer\r\n     * @returns a serialized glow layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GlowLayer\";\r\n\r\n        let index;\r\n\r\n        // Included meshes\r\n        serializationObject.includedMeshes = [];\r\n\r\n        const includedOnlyMeshes = this._thinEffectLayer._includedOnlyMeshes;\r\n        if (includedOnlyMeshes.length) {\r\n            for (index = 0; index < includedOnlyMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(includedOnlyMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.includedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        const excludedMeshes = this._thinEffectLayer._excludedMeshes;\r\n        if (excludedMeshes.length) {\r\n            for (index = 0; index < excludedMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(excludedMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.excludedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Glow Layer from parsed glow layer data\r\n     * @param parsedGlowLayer defines glow layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the glow layer information\r\n     * @returns a parsed Glow Layer\r\n     */\r\n    public static override Parse(parsedGlowLayer: any, scene: Scene, rootUrl: string): GlowLayer {\r\n        const gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);\r\n        let index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addIncludedOnlyMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        return gl;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GlowLayer\", GlowLayer);\r\n"],
  "mappings": "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",
  "names": ["engine"]
}
