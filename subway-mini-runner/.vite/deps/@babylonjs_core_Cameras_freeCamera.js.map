{
  "version": 3,
  "sources": ["../../dev/core/src/Cameras/targetCamera.ts", "../../dev/core/src/Cameras/cameraInputsManager.ts", "../../dev/core/src/Cameras/Inputs/freeCameraKeyboardMoveInput.ts", "../../dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts", "../../dev/core/src/Cameras/Inputs/BaseCameraMouseWheelInput.ts", "../../dev/core/src/Cameras/Inputs/freeCameraMouseWheelInput.ts", "../../dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts", "../../dev/core/src/Cameras/freeCameraInputsManager.ts", "../../dev/core/src/Cameras/freeCamera.ts"],
  "sourcesContent": ["import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TargetCamera\", (name, scene) => {\r\n    return () => new TargetCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    @serialize()\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    @serialize()\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected _deferredPositionUpdate = new Vector3();\r\n    protected _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const worldForward = TmpVectors.Vector3[0];\r\n        const localForward = TmpVectors.Vector3[1];\r\n        localForward.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\r\n        this.getDirectionToRef(localForward, worldForward);\r\n        worldForward.scaleInPlace(distance);\r\n        return this.globalPosition.add(worldForward);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public override storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public override _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public override _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public override _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: AbstractEngine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n        const rotation = ((this.rotationSpeed * this._engine.getDeltaTime()) / 1000) * handednessMultiplier;\r\n\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n", "import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: (evt: MouseEvent) => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * [true] Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n                        const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n            const offsetX = evt.movementX * handednessMultiplier;\r\n\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = (evt: MouseEvent) => this.onContextMenu(evt as PointerEvent);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the context menu event\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public override checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * [false] Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n        camera.cameraRotation.y = (handednessMultiplier * this._offsetX) / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n", "import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public override clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public override inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public override detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > AbstractEngine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public override dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.FreeCamera\", FreeCamera);\r\n"],
  "mappings": "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",
  "names": ["_CameraProperty"]
}
